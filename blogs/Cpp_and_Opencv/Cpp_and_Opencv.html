<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Ruoyu Chen</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="robots" content="all,follow">
    <!-- Bootstrap CSS-->
    <link rel="stylesheet" href="../../vendor/bootstrap/css/bootstrap.min.css">
    <!-- Font Awesome CSS-->
    <link rel="stylesheet" href="../../vendor/font-awesome/css/font-awesome.min.css">
    <!-- Custom icon font-->
    <link rel="stylesheet" href="../../css/fontastic.css">
    <!-- Google fonts - Open Sans-->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,400,700">
    <!-- Fancybox-->
    <link rel="stylesheet" href="../../vendor/@fancyapps/fancybox/jquery.fancybox.min.css">
    <!-- Favicon-->
    <link rel="shortcut icon" href="favicon.png">
    <!-- Tweaks for older IEs--><!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
        <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script><![endif]-->
  </head>

<style type="text/css">

/* reset
========================================*/
html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p,
	blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn,
	em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var,
	b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend,
	table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas,
	details, embed, figure, figcaption, footer, header, hgroup, menu, nav,
	output, ruby, section, summary, time, mark, audio, video {
	margin: 0;
	padding: 0;
	border: 0;
}

/* body
================================================*/
body {
	font-family: 'microsoft yahei', Helvetica, arial, freesans, clean,
		sans-serif;
	font-size: 14px;
	line-height: 1.8;
	/*color: #333;*/
	color: #3f3f3f;
	background-color: #fff;
	padding: 20px;
	max-width: 960px;
	margin: 0 auto;
	max-width: 1000px;
	word-break: break-word !important;
	word-break: break-all;
	margin-left: 20px;
	margin-bottom: 100px;
}

body>*:first-child {
	margin-top: 0 !important;
}

body>*:last-child {
	margin-bottom: 0 !important;
}

/* blocks
============================================*/
p, blockquote, ul, ol, dl, table, pre {
	margin: 15px 0;
}

/* headers
============================================*/
h1, h2, h3, h4, h5, h6 {
	font-family: 'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;
	margin: 20px 0 10px;
	padding: 0;
	font-weight: bold;
	-webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt,
	h5 code, h6 tt, h6 code {
	font-size: inherit;
}

h1 {
	font-size: 34px;
	color: #000;
}

h2 {
	font-size: 30px;
	border-bottom: 2px solid #3F3F3F;
	color: #000;
	font-weight: bold;
	-webkit-font-smoothing: antialiased;
}

h3 {
	font-size: 26px;
	font-weight: bold;
	-webkit-font-smoothing: antialiased;
}

h4 {
	font-size: 22px;
}

h5 {
	font-size: 18px;
}

h6 {
	color: #777;
	font-size: 16px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child,
	body>h4:first-child, body>h5:first-child, body>h6:first-child {
	margin-top: 0;
	padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4,
	a:first-child h5, a:first-child h6 {
	margin-top: 0;
	padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
	margin-top: 10px;
}

/* links
===================================================*/
a {
	color: #4183C4;
	text-decoration: none;
}

a:active, a:hover, a:hover, a:visited {
	color: #ca0c16;
	text-decoration: underline;
}

/* lists
==============================================*/
ul, ol {
	padding-left: 30px;
}

ul li>:first-child, ol li>:first-child, ul li ul:first-of-type, ol li ol:first-of-type,
	ul li ol:first-of-type, ol li ul:first-of-type {
	margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
	margin-bottom: 0;
}

dl {
	padding: 0;
}

dl dt {
	font-size: 14px;
	font-weight: bold;
	font-style: italic;
	padding: 0;
	margin: 15px 0 5px;
}

dl dt:first-child {
	padding: 0;
}

dl dt>:first-child {
	margin-top: 0px;
}

dl dt>:last-child {
	margin-bottom: 0px;
}

dl dd {
	margin: 0 0 15px;
	padding: 0 15px;
}

dl dd>:first-child {
	margin-top: 0px;
}

dl dd>:last-child {
	margin-bottom: 0px;
}

/* code
========================================================*/
p code {
	color: #b52a1d;
}

pre, code, tt {
	/*font-size: 13px;*/
	font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
	margin: 0 2px;
	padding: 0px 8px;
	white-space: nowrap;
	border: 1px solid #eaeaea;
	background-color: #f8f8f8;
	border-radius: 3px;
	color: #b52a1d;
}

pre>code {
	margin: 0;
	padding: 0;
	white-space: pre;
	border: none;
	background: transparent;
	/* css-3  white-space: pre-wrap; */
	white-space: -moz-pre-wrap; /* mozilla, since 1999 */
	white-space: -pre-wrap; /* opera 4-6 */
	white-space: -o-pre-wrap; /* opera 7 */
	word-wrap: break-word; /* internet explorer 5.5+ */
	overflow: auto;
	word-break: break-all;
	word-wrap: break-word;
	color: #3f3f3f;
}

pre {
	background-color: #F9F9F9;
	border: 1px solid #ccc;
	font-size: 13px;
	line-height: 19px;
	overflow: auto;
	padding: 2px 2px;
	border-radius: 3px;
}

pre code, pre tt {
	background-color: transparent;
	border: none;
}

kbd {
	-moz-border-bottom-colors: none;
	-moz-border-left-colors: none;
	-moz-border-right-colors: none;
	-moz-border-top-colors: none;
	background-color: #DDDDDD;
	background-image: linear-gradient(#F1F1F1, #DDDDDD);
	background-repeat: repeat-x;
	border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
	border-image: none;
	border-radius: 2px 2px 2px 2px;
	border-style: solid;
	border-width: 1px;
	font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
	line-height: 10px;
	padding: 1px 4px;
}

/* quotes
====================================================*/
blockquote {
	padding: 15px 20px;
	border-left: 10px solid #F1F1F1;
	background-color: #F9F9F9;
	border-radius: 0 5px 5px 0;
}

blockquote>:first-child {
	margin-top: 0px;
}

blockquote>:last-child {
	margin-bottom: 0px;
}

/* horizontal rules
======================================*/
hr {
	clear: both;
	margin: 15px 0;
	height: 0px;
	overflow: hidden;
	border: none;
	background: transparent;
	border-bottom: 4px solid #ddd;
	padding: 0;
}

/* tables
=========================================*/
table {
	font-family: Helvetica, arial, freesans, clean, sans-serif;
	padding: 0;
	border-collapse: collapse;
	border-spacing: 0;
	font-size: 1em;
	font: inherit;
	border: 0;
}

tbody {
	margin: 0;
	padding: 0;
	border: 0;
}

table tr {
	border: 0;
	border-top: 1px solid #CCC;
	background-color: white;
	margin: 0;
	padding: 0;
}

table tr:nth-child(2n) {
	background-color: #F8F8F8;
}

table tr th, table tr td {
	font-size: 1em;
	border: 1px solid #CCC;
	margin: 0;	
}

table tr th {
	padding: 0.3em 0.5em;
}

table tr td {
	padding: 0.25em 0.5em;
}

/* images
===================================================*/
img {
	max-width: 1000px;
}

strong, b {
	padding: 0 4px;
}

</style>
<style type="text/css">
.highlight  { background: #ffffff; }
.highlight .c { color: #999988; font-style: italic } /* Comment */
.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */
.highlight .k { font-weight: bold } /* Keyword */
.highlight .o { font-weight: bold } /* Operator */
.highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */
.highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */
.highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */
.highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #aa0000 } /* Generic.Error */
.highlight .gh { color: #999999 } /* Generic.Heading */
.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */
.highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #555555 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #aaaaaa } /* Generic.Subheading */
.highlight .gt { color: #aa0000 } /* Generic.Traceback */
.highlight .kc { font-weight: bold } /* Keyword.Constant */
.highlight .kd { font-weight: bold } /* Keyword.Declaration */
.highlight .kp { font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #009999 } /* Literal.Number */
.highlight .s { color: #d14 } /* Literal.String */
.highlight .na { color: #008080 } /* Name.Attribute */
.highlight .nb { color: #0086B3 } /* Name.Builtin */
.highlight .nc { color: #445588; font-weight: bold } /* Name.Class */
.highlight .no { color: #008080 } /* Name.Constant */
.highlight .ni { color: #800080 } /* Name.Entity */
.highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #990000; font-weight: bold } /* Name.Function */
.highlight .nn { color: #555555 } /* Name.Namespace */
.highlight .nt { color: #000080 } /* Name.Tag */
.highlight .nv { color: #008080 } /* Name.Variable */
.highlight .ow { font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #009999 } /* Literal.Number.Float */
.highlight .mh { color: #009999 } /* Literal.Number.Hex */
.highlight .mi { color: #009999 } /* Literal.Number.Integer */
.highlight .mo { color: #009999 } /* Literal.Number.Oct */
.highlight .sb { color: #d14 } /* Literal.String.Backtick */
.highlight .sc { color: #d14 } /* Literal.String.Char */
.highlight .sd { color: #d14 } /* Literal.String.Doc */
.highlight .s2 { color: #d14 } /* Literal.String.Double */
.highlight .se { color: #d14 } /* Literal.String.Escape */
.highlight .sh { color: #d14 } /* Literal.String.Heredoc */
.highlight .si { color: #d14 } /* Literal.String.Interpol */
.highlight .sx { color: #d14 } /* Literal.String.Other */
.highlight .sr { color: #009926 } /* Literal.String.Regex */
.highlight .s1 { color: #d14 } /* Literal.String.Single */
.highlight .ss { color: #990073 } /* Literal.String.Symbol */
.highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #008080 } /* Name.Variable.Class */
.highlight .vg { color: #008080 } /* Name.Variable.Global */
.highlight .vi { color: #008080 } /* Name.Variable.Instance */
.highlight .il { color: #009999 } /* Literal.Number.Integer.Long */
.pl-c {
    color: #969896;
}

.pl-c1,.pl-mdh,.pl-mm,.pl-mp,.pl-mr,.pl-s1 .pl-v,.pl-s3,.pl-sc,.pl-sv {
    color: #0086b3;
}

.pl-e,.pl-en {
    color: #795da3;
}

.pl-s1 .pl-s2,.pl-smi,.pl-smp,.pl-stj,.pl-vo,.pl-vpf {
    color: #333;
}

.pl-ent {
    color: #63a35c;
}

.pl-k,.pl-s,.pl-st {
    color: #a71d5d;
}

.pl-pds,.pl-s1,.pl-s1 .pl-pse .pl-s2,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre,.pl-src,.pl-v {
    color: #df5000;
}

.pl-id {
    color: #b52a1d;
}

.pl-ii {
    background-color: #b52a1d;
    color: #f8f8f8;
}

.pl-sr .pl-cce {
    color: #63a35c;
    font-weight: bold;
}

.pl-ml {
    color: #693a17;
}

.pl-mh,.pl-mh .pl-en,.pl-ms {
    color: #1d3e81;
    font-weight: bold;
}

.pl-mq {
    color: #008080;
}

.pl-mi {
    color: #333;
    font-style: italic;
}

.pl-mb {
    color: #333;
    font-weight: bold;
}

.pl-md,.pl-mdhf {
    background-color: #ffecec;
    color: #bd2c00;
}

.pl-mdht,.pl-mi1 {
    background-color: #eaffea;
    color: #55a532;
}

.pl-mdr {
    color: #795da3;
    font-weight: bold;
}

.pl-mo {
    color: #1d3e81;
}
.task-list {
padding-left:10px;
margin-bottom:0;
}

.task-list li {
    margin-left: 20px;
}

.task-list-item {
list-style-type:none;
padding-left:10px;
}

.task-list-item label {
font-weight:400;
}

.task-list-item.enabled label {
cursor:pointer;
}

.task-list-item+.task-list-item {
margin-top:3px;
}

.task-list-item-checkbox {
display:inline-block;
margin-left:-20px;
margin-right:3px;
vertical-align:1px;
}
</style>
<meta http-equiv="Expires" content="0">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Cache-control" content="no-cache">
<meta http-equiv="Cache" content="no-cache">

<link href="https://cdn.bootcss.com/prettify/r298/prettify.css" rel="stylesheet">
<link href="https://cdn.bootcss.com/prettify/r298/prettify.min.css" rel="stylesheet"> 
<script src="https://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>
<script>
	window.onload=function(){
		//load
		prettyPrint();
	}
	</script>

<script type="text/javascript"
   src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




<script type="text/javascript">
    function wrapOldContentByDiv() {
        var oldContentDiv = document.createElement("div");
        oldContentDiv.style.cssText = "float:right; width:72%; padding-left: 3%; padding-right:3%;border: 2px solid #CACACA;";
        oldContentDiv.innerHTML = document.body.innerHTML;
        document.body.style["max-width"] = "100%";
        document.body.style["margin"] = "20px";
        document.body.style["padding"] = "0";
        document.body.innerHTML = '';
        document.body.appendChild(oldContentDiv);
    };

    function addDirectorySwitch(directoryDiv) {
        var directorySwitchP = document.createElement("p");
        directorySwitchP.style.cssText = "text-align: left; margin: 0;";
        directoryDiv.appendChild(directorySwitchP);

        var ele_span = document.createElement("span");
        ele_span.style.cssText = "font-weight: 1000;";
        var ele_text = document.createTextNode("目录");
        ele_span.appendChild(ele_text);

        var ele_a = document.createElement("a");
        ele_a.appendChild(document.createTextNode("[-]"));
        ele_a.setAttribute("href", "#");
        ele_a.setAttribute("onclick", "javascript:return switchAllDirectory(this);");
        ele_a.setAttribute("title", "Click to Open TOC");

        ele_span.appendChild(ele_a);
        directorySwitchP.appendChild(ele_span);
    }

    function createTree(parentNode, tags, index, maxLevel) {
        if (index >= tags.length) {
            return -1;
        }

        var lastLevel = -1;
        for (var i = index; i < tags.length; i++) {
            var header = tags[i];
            var level = parseInt(header.tagName.substr(1), 10);

            var childNode = {'tag': header, 'childNodes': [], 'level': level};
            if (level > parentNode.level) {
                if (lastLevel > 0 && level > lastLevel) {
                    // 子子类
                    index = createTree(parentNode.childNodes[parentNode.childNodes.length - 1], tags, i);
                    if (index < 0) {
                        return -1;
                    } else {
                        i = index - 1;
                    }
                } else {
                    parentNode.childNodes.push(childNode);
                    lastLevel = level;
                }
            } else if (level <= maxLevel && parentNode.level > maxLevel) {
                parentNode.childNodes.push(childNode);
                lastLevel = level;
            } else {
                return i;
            }
        }
    }

    function createAElement(tag, index) {
        var a = document.createElement("a");
        a.style.cssText = "";
        a.setAttribute("href", "#" + tag.textContent);
        a.innerHTML = index.toString() + tag.textContent;
        return a;
    }

    function createOlElement() {
        var ol_el = document.createElement("ol");
        ol_el.style["line-height"] = "180%";
        ol_el.style["list-style-type"] = "none";
        ol_el.style["margin-left"] = "0";
        return ol_el
    }

    function createEmptyLiElement() {
        var emptyLiEle = document.createElement("li");
        return emptyLiEle
    }

    function getIndex(parentDirectory, directoryLevel, index) {
        if (directoryLevel === 0) {
            return parentDirectory + (index + 1).toString() + "."
        } else {
            return parentDirectory + (index + 1).toString() + ".";
        }
    }

    function createLeafElement(node, curDirectory) {
        var liEle = createEmptyLiElement();
        var aEle = createAElement(node.tag, curDirectory);
        liEle.appendChild(aEle);
        return liEle
    }

    function getArrowDownStyle() {
        return " width: 0;" +
            "    height: 0;" +
            "    position: relative;" +
            "    margin-right: 8px;" +
            "    top: 3px;" +
            "    display: inline-block;" +
            "    border: 6px outset;" +
            "    border-color: black transparent transparent transparent;"
    }

    function getArrowRightStyle() {
        return " width: 0;" +
            "    height: 0;" +
            "    left: 5px;" +
            "    position: relative;" +
            "    margin-right: 8px;" +
            "    display: inline-block;" +
            "    border: 6px solid;" +
            "    border-color: transparent transparent transparent black;"
    }

    /*
    <ol>
        <li><a>根节点1</a></li>
        <li><a>根节点2</a></li>
        <li>
            <div>
                <a><span>[-]</span>根节点3</a>
                <ol>
                    <li><a>子节点1</a></li>
                    <li><a>子节点2</a></li>
                    <li><a>子节点3</a></li>
                </ol>
            </div>
        </li>
        <li><a>根节点4</a></li>
     </ol>
    * */
    // node, 1.2.3 4 0
    function renderTree(node, parentDirectory, directoryLevel, index) {
        var childNodes = node.childNodes;
        var tagContent = node.tag.textContent;

        node.tag.setAttribute("id", tagContent);

        var curDirectory = getIndex(parentDirectory, directoryLevel, index);
        var directoryName = curDirectory + "&nbsp;" + tagContent;

        // 叶子节点
        if (childNodes.length === 0) {
            return "<li style='padding-left: 24px;'><a href='#" + tagContent + "'>" + directoryName + "</a></li>"
    //                return createLeafElement(node, curDirectory)
        }

        // 非叶子节点
        var childContent = "";
        for (var j = 0; j < node.childNodes.length; j++) {
            childContent += renderTree(node.childNodes[j], curDirectory, directoryLevel + 1, j);
        }

        return "<li>" +
            "   <div>" +
            "      <div>" +
            "         <div id='" + directoryName + "' class='open' style='" + getArrowDownStyle() + "' onclick='return switchDirectory(this);'></div>" +
            "         <a href='#" + tagContent + "' ondblclick='return switchByDbClick(this);'>" + directoryName + "</a>" +
            "      </div>" +
            "      <ol id='ol-" + directoryName + "' style='line-height: 180%;list-style-type: none; padding-left: 20px;'>" + childContent + "</ol>" +
            "   </div>" +
            "</li>";

        /*var liEle = createEmptyLiElement();
        var aEle = createAElement(node.tag, curDirectory);

        var parentElement = document.createElement("div");
        parentElement.appendChild(aEle);

        var olElement = createOlElement();

        var tempNode;
        for (var j = 0; j < node.childNodes.length; j++) {
            tempNode = node.childNodes[j];
            var element = renderTree(tempNode, curDirectory, directoryLevel + 1, j);
            olElement.appendChild(element);
        }
        parentElement.appendChild(olElement);

        liEle.appendChild(parentElement);
        return liEle;*/
    }

    function switchByDbClick(aEle) {
        switchDirectory(aEle.parentElement().firstChild)
    }

    // 开关目录
    function switchDirectory(ele) {
        var divEle = ele.parentNode.parentNode;
        var olEle = divEle.lastElementChild;
        if (ele.className === "open") {
            // 关闭
            olEle.style.cssText = "display:none;line-height: 180%;list-style-type: none; padding-left: 20px";
            ele.setAttribute("class", "close");
            ele.style.cssText = getArrowRightStyle();
        } else if (ele.className === "close") {
            // 打开
            olEle.style.cssText = "line-height: 180%;list-style-type: none; padding-left: 20px";
            ele.setAttribute("class", "open");
            ele.style.cssText = getArrowDownStyle();
        }
    }

    function switchAllDirectory(e) {
        var rootOlElement = document.getElementById("outline_ol");
        var ols = rootOlElement.getElementsByTagName("ol");
        var isOpen = false;

        if (e.innerHTML === '[+]') {
            e.setAttribute('title', 'collapse');
            e.innerHTML = '[-]';
            isOpen = true;
        } else {
            e.setAttribute('title', 'expand');
            e.innerHTML = '[+]';
        }


        for (var i = 0; i < ols.length; i++) {
            var olEle = ols[i];
            if (isOpen) {
                olEle.style.display = "block";
                olEle.parentNode.firstElementChild.firstElementChild.style.cssText = getArrowDownStyle();
            } else {
                olEle.style.display = "none";
                olEle.parentNode.firstElementChild.firstElementChild.style.cssText = getArrowRightStyle();
            }
        }

        e.blur();
        return false;
    }

    document.addEventListener("DOMContentLoaded", function () {
        // 1, 将body内容提取到div标签中
        wrapOldContentByDiv();

        // 2, 创建左边目录列表Div
        var directoryDiv = document.createElement("div");
        directoryDiv.setAttribute("id", "outline-list");
        directoryDiv.style.cssText = "width:20%;height:100%; float:left;font-size:16px,z-index:1;position: fixed;overflow: hidden;";

        // 3, 目录展开折叠开关
        addDirectorySwitch(directoryDiv);

        // 4, 创建目录列表
        var directoryOl = document.createElement("ol");
        directoryOl.style.cssText = "padding-left:14px;line-height:180%;list-style-type:none;height: 85%;padding-bottom: 30px; overflow: auto;";
        directoryOl.setAttribute("id", "outline_ol");
        directoryDiv.appendChild(directoryOl);
        var div1 = document.createElement("div");
        div1.style.cssText = "clear:both";

        // 插入目录
        document.body.insertBefore(directoryDiv, document.body.childNodes[0]);

        // 5, 获取所有的H标签
        var hTags = document.querySelectorAll('h1,h2,h3,h4,h5,h6');
        if (hTags.length < 2)
            return;

        var rootNode = {'tag': directoryOl, 'childNodes': [], 'level': 0};
        var maxLevel = parseInt(hTags[0].tagName.substr(1), 10);
        // 6, 创建树形结构
        createTree(rootNode, hTags, 0, maxLevel);

        // 7, 绘制树结构
        var htmlContent = "";
        for (var j = 0; j < rootNode.childNodes.length; j++) {
    //                var element = renderTree(rootNode.childNodes[j], '', 1, j);
    //                directoryOl.appendChild(element);

            htmlContent += renderTree(rootNode.childNodes[j], '', 1, j);
        }
        directoryOl.innerHTML = htmlContent;
    });
</script>
</head>

<body>

<header class="header">
      <!-- Main Navbar-->
      <nav class="navbar navbar-expand-lg">
        <div class="search-area">
          <div class="search-area-inner d-flex align-items-center justify-content-center">
            <div class="close-btn"><i class="icon-close"></i></div>
            <div class="row d-flex justify-content-center">
              <div class="col-md-8">
                <form action="#">
                  <div class="form-group">
                    <input type="search" name="search" id="search" placeholder="What are you looking for?">
                    <button type="submit" class="submit"><i class="icon-search-1"></i></button>
                  </div>
                </form>
              </div>
            </div>
          </div>
        </div>
        <div class="container">
          <!-- Navbar Brand -->
          <div class="navbar-header d-flex align-items-center justify-content-between">
            <!-- Navbar Brand --><a href="#" class="navbar-brand"><font size="6" color="blue" face="Times">CExplorer</font></a>
            <!-- Toggle Button-->
            <button type="button" data-toggle="collapse" data-target="#navbarcollapse" aria-controls="navbarcollapse" aria-expanded="false" aria-label="Toggle navigation" class="navbar-toggler"><span></span><span></span><span></span></button>
          </div>
          <!-- Navbar Menu -->
          <div id="navbarcollapse" class="collapse navbar-collapse">
            <ul class="navbar-nav ml-auto">
              <li class="nav-item"><a href="../../index.html" class="nav-link ">Home</a>
              </li>
              <li class="nav-item"><a href="#" class="nav-link ">Research</a>
              </li>
              <li class="nav-item"><a href="#" class="nav-link ">Publications</a>
              </li>
              <li class="nav-item"><a href="#" class="nav-link ">Datasets</a>
              </li>
			  <li class="nav-item"><a class="nav-link active ">Blog</a>
              </li>
            </ul>
            <div class="navbar-text"><a href="#" class="search-btn"><i class="icon-search-1"></i></a></div>
            <ul class="langs navbar-text"><a class="active">English</a><span>           </span><a href="index_CN.html">中文</a></ul>
          </div>
        </div>
      </nav>
    </header>
	
<h1 id="-center-opencv-c-center-"><center>用OpenCV和C++轻松玩转数字图像处理</center></h1>
<blockquote>
<p>作者：陈若愚<br>QQ : 2389388826<br>日期：2020年/2月/29日<br>版本：v1.1</p>
</blockquote>
<hr>
<h2 id="abstract">Abstract</h2>
<p>图像处理是我们很多学生进入科研或者科创的一个选则，因为他入门的门槛很低，实践性很强，而且不像仪器类学科需要科研设备或者深度学习需要强大的计算服务器。目前主流的图像处理是matlab，因为matlab是数据科学常用的一门语言，操作简单，但是matlab在计算速度方面存在问题，而且并不适合工业领域。C++，面向对象的编程，可以算是非常难的一门语言了，但是由于很多软件工程师的努力，我们现在可以非常简单地使用C++和Opencv开源软件进行数字图像处理，希望我的学习记录能够让大家快速入门。</p>
<hr>
<h2 id="0-">0. 常用库</h2>
<pre class="prettyprint lang-c">
#include < iostream>  
#include < opencv2/core/core.hpp>  
#include < opencv2/highgui/highgui.hpp>  
#include < opencv2/opencv.hpp>
#include < opencv2/imgproc.hpp>
#include < opencv2/core/types_c.h>
#include < opencv2/imgproc/imgproc_c.h>
#include < cassert>
#include < vector> 

</pre>

<h2 id="1-">1. 图像读入、显示与保存</h2>
<blockquote>
<p>本人不习惯使用命名空间，这里只记录一下命名空间与非命名空间的比较，后面代码全部使用非命名空间形式</p>
</blockquote>
<ul>
<li>不含命名空间格式：</li></ul>
<pre class="prettyprint lang-c++">
#include < iostream>  
#include < opencv2/core/core.hpp>  
#include < opencv2/highgui/highgui.hpp>
#include < opencv2/opencv.hpp>
#include < opencv2/imgproc.hpp>  

int main()
{
    // 工作台输出
    std::cout << "Hello OpenCV!" << std::endl;
    // 读入一张图片 
    cv::Mat img = cv::imread("Lena.jfif");
    // 判断图片读取是否有误    
    if (!img.data)
    {
        std::cout << "读取原始图失败！" << std::endl;
        return -1;
    }  
    // 创建一个名为 "图片"窗口
    cv::namedWindow("Lena");
    // 在窗口中显示图片   
    cv::imshow("Lena", img);
    // 等待6000 ms后窗口自动关闭    
    cv::waitKey(6000);
    // 将图片保存为jpg格式
    cv::imwrite("Lena.jpg", img);
    return 0;
}
</pre>

<ul>
<li>含命名空间格式：</li></ul>
<pre class="prettyprint lang-c++">
#include < iostream>  
#include < opencv2/core/core.hpp>  
#include < opencv2/highgui/highgui.hpp>
#include < opencv2/opencv.hpp>
#include < opencv2/imgproc.hpp>  

using namespace std;
using namespace cv;

int main()
{
    // 工作台输出
    cout << "Hello OpenCV!" << endl;
    // 读入一张图片 
    Mat img = imread("Lena.jfif");
    // 创建一个名为 "图片"窗口    
    namedWindow("Lena");
    // 在窗口中显示图片   
    imshow("Lena", img);
    // 等待6000 ms后窗口自动关闭    
    waitKey(6000);
    // 将图片保存为jpg格式
    imwrite("Lena.jpg", img);
    return 0;
}
</pre>

<ul>
<li>输出结果：<br><center><img src="./imgs\1Lena.jpg" alt=""></center><br>并且可以看到保存的jpg格式的图片，以上便是最基本的读取，显示与保存图像。</li></ul>
<h2 id="2-">2. 图像处理基础</h2>
<h3 id="2-1-">2.1 灰度图转化</h3>
<pre class="prettyprint lang-c++">
#include < iostream>  
#include < opencv2/core/core.hpp>  
#include < opencv2/highgui/highgui.hpp>  
#include < opencv2/opencv.hpp>
#include < opencv2/imgproc.hpp>

int main()
{
    // 工作台输出
    std::cout << "Hello OpenCV!" << std::endl;
    // 读入一张图片
    cv::Mat img = cv::imread("Lena.jfif");
    // 定义灰度图
    cv::Mat gray_img;
    cv::cvtColor(img, gray_img, cv::COLOR_BGR2GRAY); //旧版用CV_RGB2GRAY
    // 在窗口中显示图片
    cv::imshow("Lena", img);
    cv::imshow("Gray", gray_img);
    // 手动窗口关闭后结束    
    cv::waitKey(0);
    return 0;
}
</pre>

<ul>
<li>输出结果：</li></ul>
<center><img src="imgs\2gray.jpg" alt=""></center>

<h3 id="2-2-">2.2 获取图像属性</h3>
<pre class="prettyprint lang-c++">
#include < iostream>  
#include < opencv2/core/core.hpp>  
#include < opencv2/highgui/highgui.hpp>  
#include < opencv2/opencv.hpp>
#include < opencv2/imgproc.hpp>

int main()
{
    cv::Mat img = cv::imread("Lena.jfif");
    //宽度
    int col = img.cols;
    std::cout << "宽度：" << col << std::endl;
    //高度
    int row = img.rows;
    std::cout << "高度：" << row << std::endl;
    //通道数
    int channel = img.channels();
    std::cout << "通道数：" << channel << std::endl;
    system("pause");
    return 0;
}
</pre>

<ul>
<li>输出结果：</li></ul>
<center><img src="imgs\3shape.jpg" alt=""></center>

<h3 id="2-3-">2.3 读取与修改像素</h3>
<h4 id="-1-opencv-at-">（1）使用OpenCV的at成员函数</h4>
<table>
<thead>
<tr>
<th style="text-align:center">图像类型</th>
<th style="text-align:center">参数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">单通道灰度</td>
<td style="text-align:center">unsigned char</td>
</tr>
<tr>
<td style="text-align:center">三通道彩色（8位）</td>
<td style="text-align:center">cv::Vec3b</td>
</tr>
<tr>
<td style="text-align:center">16位灰度</td>
<td style="text-align:center">unsigned short</td>
</tr>
<tr>
<td style="text-align:center">32位浮点型</td>
<td style="text-align:center">float</td>
</tr>
<tr>
<td style="text-align:center">双通道32位</td>
<td style="text-align:center">cv::Vec2f</td>
</tr>
</tbody>
</table>
<ul>
<li>Example(彩色图像部分修改)</li></ul>
<pre class="prettyprint lang-c++">
#include < iostream>  
#include < opencv2/core/core.hpp>  
#include < opencv2/highgui/highgui.hpp>  
#include < opencv2/opencv.hpp>
#include < opencv2/imgproc.hpp>

int main()
{
    // 读取图像
    cv::Mat img = cv::imread("Lena.jfif");
    // 读取(35，35)的B,G,R值
    cv::Vec3b& bgr = img.at<cv::Vec3b>(35, 35);
    std::cout << "R通道：" << int(bgr[2]) << std::endl;
    std::cout << "G通道：" << int(bgr[1]) << std::endl;
    std::cout << "B通道：" << int(bgr[0]) << std::endl;
    // 修改图像左上角1/4图像为白色
    for (int r = 0; r < img.rows/2; r++)//行
    {
        for (int c = 0; c < img.cols/2; c++)//列
        {
            cv::Vec3b& bgr = img.at<cv::Vec3b>(r, c);
            bgr[0] = 255;        //B通道
            bgr[1] = 255;        //G通道
            bgr[2] = 255;        //R通道
        }
    }

    cv::imshow("After process", img);
    cv::waitKey(0);
    return 0;
}
</pre>

<ul>
<li>输出结果：<center><img src="imgs\4read_and_write.jpg" alt=""></center>

</li></ul>
<h3 id="2-4-roi">2.4 提取感兴趣区域ROI</h3>
<ul>
<li>Example:提取Lena的脸部图像，并在原图中框出来</li></ul>
<pre class="prettyprint lang-c++">
#include < iostream>  
#include < opencv2/core/core.hpp>  
#include < opencv2/highgui/highgui.hpp>  
#include < opencv2/opencv.hpp>
#include < opencv2/imgproc.hpp>

int main(){
    // 读取图像
    cv::Mat img = cv::imread("Lena.jfif");
    // 判断图片读取是否有误    
    if (!img.data)
    {
        std::cout << "读取原始图失败！" << std::endl;
        return -1;
    }
    cv::Mat imageROI;
    imageROI = img(cv::Rect(80, 80, 70, 70));//Rect四个形参分别是：x坐标，y坐标，长，高；注意(x,y)指的是矩形的左上角点
    cv::imshow("face", imageROI);
    cv::rectangle(img, cv::Rect(80, 80, 70, 70), cv::Scalar(0, 255, 0), 3); //将感兴趣区域框出来,这里是用3像素的绿色线标注出来
    cv::imshow("ROI", img);
    cv::waitKey(0);
}
</pre>

<ul>
<li>输出结果：<center><img src="imgs\5ROI.jpg" alt=""></center>

</li></ul>
<h3 id="2-5-">2.5 图像通道拆分与合并</h3>
<ul>
<li>Example:拆分通道，再将通道顺序取反合并</li></ul>
<pre class="prettyprint lang-c++">
#include < iostream>  
#include < opencv2/core/core.hpp>  
#include < opencv2/highgui/highgui.hpp>  
#include < opencv2/opencv.hpp>
#include < opencv2/imgproc.hpp>
#include < cassert>  
#include < vector> 

int main()
{
    // 读取图像
    cv::Mat img = cv::imread("Lena.jfif");
    assert(img.data != NULL);
    // 定义变量
    cv::Mat img_Blue, img_Green, img_Red;
    std::vector<cv::Mat> channels;
    // 拆分通道
    cv::split(img, channels);
    img_Blue = channels.at(0);
    img_Green = channels.at(1);
    img_Red = channels.at(2);
    cv::imshow("Original", img);
    cv::imshow("B", img_Blue);
    cv::imshow("G", img_Green);
    cv::imshow("R", img_Red);
    cv::waitKey(0);
    // 合并通道（更改顺序）
    cv::Mat mergeImage;
    channels.at(0) = img_Red;
    channels.at(2) = img_Blue;
    cv::merge(channels, mergeImage);
    cv::imshow("mergeImage", mergeImage);
    cv::waitKey(0);
    return 0;
}
</pre>

<ul>
<li>输出结果：</li></ul>
<center><img src="imgs\6Split.jpg" alt=""><br>拆分通道的图像</center>

<center><img src="imgs\7Merge.jpg" alt=""><br>合并后的图像<br></center>

<h2 id="3-">3. 图像运算</h2>
<ul>
<li>Example:两个size相同的图片相加</li></ul>
<pre class="prettyprint lang-c++">
#include < iostream>  
#include < opencv2/core/core.hpp>  
#include < opencv2/highgui/highgui.hpp>  
#include < opencv2/opencv.hpp>
#include < opencv2/imgproc.hpp>
#include < cassert>  
#include < vector>

int main()
{
    // 读取图像
    cv::Mat Lena = cv::imread("Lena.jfif");
    cv::Mat opencv = cv::imread("opencv.jpg");
    cv::Mat addimg;
    double alpha = 0.5, belta = 0.5;
    cv::addWeighted(Lena, alpha, opencv, belta, 0.0, addimg);
    cv::imshow("addimg", addimg);
    cv::waitKey(0);
    return 0;
}
</pre>

<ul>
<li>输出结果：</li></ul>
<center><img src="imgs\9Addweight.jpg" alt=""></center>

<h2 id="4-">4. 类型转换</h2>
<ul>
<li><p>格式：<code>cv::cvtColor(src,dst,dtype)</code></p>
</li><li><p>Example: RGB图转灰度与BGR类型</p>
</li></ul>
<pre class="prettyprint lang-c++">
#include < iostream>  
#include < opencv2/core/core.hpp>  
#include < opencv2/highgui/highgui.hpp>  
#include < opencv2/opencv.hpp>
#include < opencv2/imgproc.hpp>
#include < cassert>  
#include < vector>

int main()
{
    // 读取图像
    cv::Mat img = cv::imread("Lena.jfif");
    cv::Mat gray_img,bgr_img;
    // 转灰度图
    cv::cvtColor(img, gray_img, cv::COLOR_BGR2GRAY);
    // 转BGR->RGB通道
    cv::cvtColor(img, bgr_img, cv::COLOR_BGR2RGB);
    // 结果显示
    cv::imshow("Lena", img);
    cv::imshow("gray_img",gray_img);
    cv::imshow("bgr_img", bgr_img);
    cv::waitKey(0);
    return 0;
}
</pre>

<ul>
<li>输出结果：<center><img src="imgs\10Datacvt.jpg" alt=""></center>

</li></ul>
<h2 id="5-">5. 几何变换</h2>
<h3 id="5-1-">5.1 图像缩放</h3>
<pre class="prettyprint lang-c++">
#include < iostream>  
#include < opencv2/core/core.hpp>  
#include < opencv2/highgui/highgui.hpp>  
#include < opencv2/opencv.hpp>
#include < opencv2/imgproc.hpp>
#include < cassert>  
#include < vector>

int main()
{
    // 读取图像
    cv::Mat img = cv::imread("opencv.jfif");
    assert(img.data != NULL);
    cv::Mat sizeimg;
    // 定义缩放大小
    cv::Size dsize = cv::Size(200, 200);
    // 定义缩放
    cv::resize(img, sizeimg, dsize);
    cv::imshow("Original", img);
    cv::imshow("Resize", sizeimg);
    cv::waitKey(0);
    cv::imwrite("opencv.jpg", sizeimg);
    return 0;
}
</pre>

<ul>
<li>输出结果：<center><img src="imgs\8Resize.jpg" alt=""></center>

</li></ul>
<h3 id="5-2-">5.2 图像翻转</h3>
<pre class="prettyprint lang-c++">
#include < iostream>  
#include < opencv2/core/core.hpp>  
#include < opencv2/highgui/highgui.hpp>  
#include < opencv2/opencv.hpp>
#include < opencv2/imgproc.hpp>
#include < opencv2/core/types_c.h>
#include < opencv2/imgproc/imgproc_c.h>
#include < cassert>  
#include < vector> 

cv::Mat RotateImage(cv::Mat src, double angle)
{
    cv::Mat dst;
    try
    {
        //float scale = 200.0/ src.rows;//缩放因子    
        //cv::resize(src, src, cv::Size(), scale, scale, cv::INTER_LINEAR);                
        //输出图像的尺寸与原图一样    
        cv::Size dst_sz(src.cols, src.rows);
        //指定旋转中心      
        cv::Point2f center(static_cast<float>(src.cols / 2.), static_cast<float>(src.rows / 2.));
        //获取旋转矩阵（2x3矩阵）      
        cv::Mat rot_mat = cv::getRotationMatrix2D(center, angle, 1.0);
        //设置选择背景边界颜色   
        /*cv::Scalar borderColor = Scalar(0, 238, 0);*/
        /*cv::warpAffine(src, dst, rot_mat, src.size(), INTER_LINEAR, BORDER_CONSTANT, borderColor);*/
        //复制边缘填充
        cv::warpAffine(src, dst, rot_mat, dst_sz, cv::INTER_LINEAR, cv::BORDER_REPLICATE);
    }
    catch (cv::Exception e)
    {
    }
    return dst;
}

int main(int argc, char* argv[])

{
    cv::Mat img = cv::imread("Lena.jfif");
    cv::imshow("source",img);
    cv::Mat m_ResImg = RotateImage(img, 90);
    cv::imshow("RotateImage", m_ResImg);
    cv::Mat m_ResImg2 = RotateImage(img, 30);
    cv::imshow("RotateImage2", m_ResImg2);
    cv::waitKey(0);
    return 0;
}
</pre>

<ul>
<li>输出结果：<center><img src="imgs\11Rotate.jpg" alt=""></center>

</li></ul>
<h2 id="6-">6. 直方图</h2>
<pre class="prettyprint lang-c++">
#include < iostream>  
#include < opencv2/core/core.hpp>  
#include < opencv2/highgui/highgui.hpp>  
#include < opencv2/opencv.hpp>
#include < opencv2/imgproc.hpp>
#include < opencv2/core/types_c.h>
#include < opencv2/imgproc/imgproc_c.h>
#include < cassert>  
#include < vector> 

int main(int argc, char* argv)
{
    cv::Mat img, dst, dst1;
    img = cv::imread("Lena.jfif");
    cv::imshow("Lena", img);

    //步骤一：分通道显示
    std::vector<cv::Mat> bgr_planes;
    cv::split(img, bgr_planes);
    //split(// 把多通道图像分为多个单通道图像 const Mat &src, //输入图像 Mat* mvbegin）// 输出的通道图像数组

    //步骤二：计算直方图
    int histsize = 256;
    float range[] = { 0,256 };
    const float* histRanges = { range };
    cv::Mat b_hist, g_hist, r_hist;
    cv::calcHist(&bgr_planes[0], 1, 0, cv::Mat(), b_hist, 1, &histsize, &histRanges, true, false);
    cv::calcHist(&bgr_planes[1], 1, 0, cv::Mat(), g_hist, 1, &histsize, &histRanges, true, false);
    cv::calcHist(&bgr_planes[2], 1, 0, cv::Mat(), r_hist, 1, &histsize, &histRanges, true, false);

    //归一化
    int hist_h = 400;//直方图的图像的高
    int hist_w = 512;////直方图的图像的宽
    int bin_w = hist_w / histsize;//直方图的等级
    cv::Mat histImage(hist_w, hist_h, CV_8UC3, cv::Scalar(0, 0, 0));//绘制直方图显示的图像
    cv::normalize(b_hist, b_hist, 0, hist_h, cv::NORM_MINMAX, -1, cv::Mat());//归一化
    cv::normalize(g_hist, g_hist, 0, hist_h, cv::NORM_MINMAX, -1, cv::Mat());
    cv::normalize(r_hist, r_hist, 0, hist_h, cv::NORM_MINMAX, -1, cv::Mat());

    //步骤三：绘制直方图（render histogram chart）
    for (int i = 1; i < histsize; i++)
    {
        //绘制蓝色分量直方图
        line(histImage, cv::Point((i - 1) * bin_w, hist_h - cvRound(b_hist.at<float>(i - 1))),
            cv::Point((i)*bin_w, hist_h - cvRound(b_hist.at<float>(i))), cv::Scalar(255, 0, 0), 2, CV_AA);
        //绘制绿色分量直方图
        line(histImage, cv::Point((i - 1) * bin_w, hist_h - cvRound(g_hist.at<float>(i - 1))),
            cv::Point((i)*bin_w, hist_h - cvRound(g_hist.at<float>(i))), cv::Scalar(0, 255, 0), 2, CV_AA);
        //绘制红色分量直方图
        line(histImage, cv::Point((i - 1) * bin_w, hist_h - cvRound(r_hist.at<float>(i - 1))),
            cv::Point((i)*bin_w, hist_h - cvRound(r_hist.at<float>(i))), cv::Scalar(0, 0, 255), 2, CV_AA);
    }
    cv::imshow("histogram image", histImage);
    cv::waitKey(0);
    return 0;
}
</pre>

<ul>
<li>输出结果：<center><img src="imgs\14hist.jpg" alt=""></center>

</li></ul>
<h2 id="7-">7. 图像滤波</h2>
<ul>
<li>Example:方框滤波，均值滤波，中值滤波，高斯滤波</li></ul>
<pre class="prettyprint lang-c++">
#include < iostream>  
#include < opencv2/core/core.hpp>  
#include < opencv2/highgui/highgui.hpp>  
#include < opencv2/opencv.hpp>
#include < opencv2/imgproc.hpp>
#include < opencv2/core/types_c.h>
#include < opencv2/imgproc/imgproc_c.h>
#include < cassert>  
#include < vector> 

int main(int argc, char* argv)
{
    //读取原始图像
    cv::Mat srcImage = cv::imread("Lena.jfif");
    cv::imshow("original", srcImage);
    //进行滤波
    cv::Mat boxfilter, meanFilter, gaussFilter, medianFilter;
    cv::boxFilter(srcImage, boxfilter, -1, cv::Size(6, 6));//方框滤波；depth=-1，表示和原图像一致
    cv::blur(srcImage, meanFilter, cv::Size(6, 6));//均值滤波
    cv::medianBlur(srcImage, medianFilter, 21);// 中值滤波
    cv::GaussianBlur(srcImage, gaussFilter, cv::Size(5, 5), 0, 0);//高斯滤波的size必须为正数和奇数
    //显示结果
    cv::imshow("boxfilter", boxfilter);
    cv::imshow("meanFilter", meanFilter);
    cv::imshow("medianFilter", medianFilter);
    cv::imshow("gaussFilter", gaussFilter);
    cv::waitKey(0);
    return 0;
}
</pre>

<ul>
<li>输出结果：<center><img src="imgs\15blur.jpg" alt=""></center>

</li></ul>
<h2 id="8-">8. 阈值分割</h2>
<h3 id="8-1-">8.1 固定阈值化</h3>
<center><img src="imgs\thresh.jpg" alt=""></center>

<pre class="prettyprint lang-c++">
#include < iostream>  
#include < opencv2/core/core.hpp>  
#include < opencv2/highgui/highgui.hpp>  
#include < opencv2/opencv.hpp>
#include < opencv2/imgproc.hpp>
#include < opencv2/core/types_c.h>
#include < opencv2/imgproc/imgproc_c.h>
#include < cassert>  
#include < vector> 

int main(int argc, char* argv[])
{
    // 读入一张图像
    cv::Mat img = cv::imread("Lena.jfif");
    // 定义变量
    cv::Mat matGray, matTHRESH_BINARY, matTHRESH_BINARY_INV, matTHRESH_TRUNC, matTHRESH_TOZERO, matTHRESH_TOZERO_INV;
    // 转灰度图
    cv::cvtColor(img, matGray, CV_BGR2GRAY);
    // 5种阈值化
    cv::threshold(matGray, matTHRESH_BINARY, 156, 255, CV_THRESH_BINARY);
    cv::threshold(matGray, matTHRESH_BINARY_INV, 156, 255, CV_THRESH_BINARY_INV);
    cv::threshold(matGray, matTHRESH_TRUNC, 156, 255, CV_THRESH_TRUNC);
    cv::threshold(matGray, matTHRESH_TOZERO, 156, 255, CV_THRESH_TOZERO);
    cv::threshold(matGray, matTHRESH_TOZERO_INV, 156, 255, CV_THRESH_TOZERO_INV);
    // 显示图像
    cv::imshow("Gray", matGray);
    cv::imshow("THRESH_BINARY", matTHRESH_BINARY);
    cv::imshow("THRESH_BINARY_INV", matTHRESH_BINARY_INV);
    cv::imshow("THRESH_TRUNC", matTHRESH_TRUNC);
    cv::imshow("THRESH_TOZERO", matTHRESH_TOZERO);
    cv::imshow("THRESH_TOZERO_INV", matTHRESH_TOZERO_INV);
    cv::waitKey(0);
    return 0;
}
</pre>

<ul>
<li>输出结果：<center><img src="imgs\12thresh.jpg" alt=""></center>


</li></ul>
<h3 id="8-2-">8.2 自适应阈值</h3>
<p>在图像阈值化操作中，我们更关心的是从二值化图像中分离目标区域和背景区域，仅仅通过固定阈值很难达到理想的分割效果。在图片中的灰度是不均匀的，所以通常情况下图片中不同区域的阈值时不一样的。在不同局部选取阈值的方法有多种。在OpenCV中实现了两种方法：(1）局部邻域块的均值；(2）局部邻域块的高斯加权和。其函数原型如下：</p>
<pre class="prettyprint lang-c++">
void adaptiveThreshold(InoutArray src,OutputArray dst,double maxValue,int adaptiveMethod,int thresholdType,int blockSize,double C)
</pre>

<p><code>src</code>表示源图像数组；<br><code>dst</code>表示输出图像组；<br><code>maxValue</code>表示预设满足条件最大值；<br><code>adaptiveMethod</code>表示自适应阈值算法选择 <code>ADAPTIVE_THRESH_MEAN_C</code>或<code>ADAPTIVE_THRESH_GAUSSIAN_C</code>;<br><code>ADAPTIVE_THRESH_MEAN_C</code>的计算方法是计算出邻域的平均值再减去第七个参数double C的值<br><code>ADAPTIVE_THRESH_GAUSSIAN_C</code>的计算方法是计算出邻域的高斯均匀值再减去第七个参数<code>double C</code>的值<br><code>thresholdType</code>表示阈值类型<code>THRESH_BINARY</code>或<code>THRESH_BINARY_INV</code>;<br><code>blockSize</code>表示邻域块大小，用来计算区域阈值，一般选择3、5、7……;<br>参数<code>C</code>表示常数，它是一个从均匀或加权均值提取的常数，可以是负数。</p>
<pre class="prettyprint lang-c++">
#include < iostream>  
#include < opencv2/core/core.hpp>  
#include < opencv2/highgui/highgui.hpp>  
#include < opencv2/opencv.hpp>
#include < opencv2/imgproc.hpp>
#include < opencv2/core/types_c.h>
#include < opencv2/imgproc/imgproc_c.h>
#include < cassert>  
#include < vector> 

int main(int argc, char* argv[])
{
    // 读入一张图像
    cv::Mat img = cv::imread("Lena.jfif");
    // 定义变量
    cv::Mat matGray, matAdaptive;
    cv::cvtColor(img, matGray, CV_BGR2GRAY);
    // adaptiveThreshold(matGray, matAdaptive, 255, ADAPTIVE_THRESH_MEAN_C, THRESH_BINARY_INV, 5, 5);
    cv::adaptiveThreshold(matGray, matAdaptive, 255, cv::ADAPTIVE_THRESH_GAUSSIAN_C, cv::THRESH_BINARY_INV, 5, 5);
    cv::imshow("gray", matGray);
    cv::imshow("adaptive", matAdaptive);
    cv::waitKey(0);
    return 0;
}
</pre>

<ul>
<li>输出结果：<center><img src="imgs\13ada.jpg" alt=""></center>



</li></ul>
<h2 id="9-">9. 形态学操作</h2>
<h3 id="9-1-">9.1 图像腐蚀</h3>
<p>卷积核：</p>
<pre class="prettyprint lang-c++">
[  1,   1,   1;
   1,   1,   1;
   1,   1,   1]
</pre>

<p>参考代码：</p>
<pre class="prettyprint lang-c++">
#include < iostream>  
#include < opencv2/core/core.hpp>  
#include < opencv2/highgui/highgui.hpp>  
#include < opencv2/opencv.hpp>
#include < opencv2/imgproc.hpp>
#include < opencv2/core/types_c.h>
#include < opencv2/imgproc/imgproc_c.h>
#include < cassert>  
#include < vector> 

int main(int argc, char* argv)
{
    //读取原始图像
    cv::Mat srcImage = cv::imread("Lena.jfif");
    // 转灰度图
    cv::Mat matGray, matTHRESH_BINARY,out;
    cv::cvtColor(srcImage, matGray, CV_BGR2GRAY);
    // 5种阈值化
    cv::threshold(matGray, matTHRESH_BINARY, 156, 255, CV_THRESH_BINARY);
    //获取自定义核
    cv::Mat element = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(3, 3));
    std::cout << element << std::endl;
    //进行腐蚀操作  
    cv::erode(matTHRESH_BINARY, out, element);
    cv::imshow("src", matTHRESH_BINARY);
    cv::imshow("erode", out);
    cv::waitKey(0);
    return 0;
}
</pre>

<ul>
<li>输出结果：<center><img src="imgs\16erode.jpg" alt=""></center>

</li></ul>
<h3 id="9-2-">9.2 图像膨胀</h3>
<pre class="prettyprint lang-c++">
#include < iostream>  
#include < opencv2/core/core.hpp>  
#include < opencv2/highgui/highgui.hpp>  
#include < opencv2/opencv.hpp>
#include < opencv2/imgproc.hpp>
#include < opencv2/core/types_c.h>
#include < opencv2/imgproc/imgproc_c.h>
#include < cassert>  
#include < vector> 

int main(int argc, char* argv)
{
    //读取原始图像
    cv::Mat srcImage = cv::imread("Lena.jfif");
    // 转灰度图
    cv::Mat matGray, matTHRESH_BINARY,out;
    cv::cvtColor(srcImage, matGray, CV_BGR2GRAY);
    // 5种阈值化
    cv::threshold(matGray, matTHRESH_BINARY, 156, 255, CV_THRESH_BINARY);
    //获取自定义核
    cv::Mat element = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(3, 3));
    std::cout << element << std::endl;
    //进行膨胀操作  
    cv::dilate(matTHRESH_BINARY, out, element);
    cv::imshow("src", matTHRESH_BINARY);
    cv::imshow("erode", out);
    cv::waitKey(0);
    return 0;
}
</pre>

<ul>
<li>输出结果：<center><img src="imgs\17dilate.jpg" alt=""></center>

</li></ul>
<h3 id="9-3-">9.3 开运算</h3>
<h3 id="9-4-">9.4 闭运算</h3>
<h3 id="9-5-">9.5 梯度运算</h3>
<h3 id="9-6-">9.6 礼帽操作</h3>
<h3 id="9-7-">9.7 黑帽图像处理</h3>
<h2 id="10-">10. 图像梯度</h2>
<h3 id="10-1-rebert-">10.1 Rebert算子</h3>
<p>算子：</p>
<center><img src="imgs\Rebert.jpg" alt=""></center>

<pre class="prettyprint lang-c++">
#include < iostream>  
#include < opencv2/core/core.hpp>  
#include < opencv2/highgui/highgui.hpp>  
#include < opencv2/opencv.hpp>
#include < opencv2/imgproc.hpp>
#include < opencv2/core/types_c.h>
#include < opencv2/imgproc/imgproc_c.h>
#include < cassert>  
#include < vector> 

int main(int argc, char* argv)
{
    //读取原始图像
    cv::Mat srcImage = cv::imread("Lena.jfif");
    cv::imshow("src", srcImage);
    //Robert X 算子
    cv::Mat robert_x = (cv::Mat_<int>(2, 2) << 1, 0, 0, -1);
    filter2D(srcImage, robert_x, -1, robert_x, cv::Point(-1, -1), 0.0);
    cv::imshow("robertx", robert_x);

    //Robert Y 算子
    cv::Mat robert_y = (cv::Mat_<int>(2, 2) << 0, 1, -1, 0);
    cv::filter2D(srcImage, robert_y, -1, robert_y, cv::Point(-1, -1), 0.0);
    cv::imshow("roberty", robert_y);
    cv::waitKey(0);
    return 0;
}
</pre>

<ul>
<li>输出结果：<center><img src="imgs\20Rebert.jpg" alt=""></center>

</li></ul>
<h3 id="10-2-sobel-">10.2 Sobel算子</h3>
<p>算子：</p>
<center><img src="imgs\Sobel.jpg" alt=""></center>

<pre class="prettyprint lang-c++">
#include < iostream>  
#include < opencv2/core/core.hpp>  
#include < opencv2/highgui/highgui.hpp>  
#include < opencv2/opencv.hpp>
#include < opencv2/imgproc.hpp>
#include < opencv2/core/types_c.h>
#include < opencv2/imgproc/imgproc_c.h>
#include < cassert>  
#include < vector> 

int main(int argc, char* argv)
{
    //读取原始图像
    cv::Mat srcImage = cv::imread("Lena.jfif");
    cv::imshow("src", srcImage);
    cv::Mat dst, gray, grad_x, gray_y, abs_grad_x, abs_grad_y;
    //转成灰度图
    cv::cvtColor(srcImage, gray, cv::COLOR_BGR2GRAY);
    //均值滤波降噪，也可以用其他滤波方法
    blur(gray, srcImage, cv::Size(3, 3));
    //运行Sobel算子，得到边缘
    //求x方向梯度
    cv::Sobel(srcImage, grad_x, CV_16S, 1, 0, 3);
    cv::convertScaleAbs(grad_x, abs_grad_x);//提取的深度图片进行显示时，由于是16位图片，要将图片转化成为8位图形进行显示 
    cv::imshow("x_sobel", abs_grad_x);
    //运行Sobel算子，得到边缘
    //求y方向梯度
    cv::Sobel(srcImage, gray_y, CV_16S, 0, 1, 3);
    cv::convertScaleAbs(gray_y, abs_grad_y);
    cv::imshow("y_sobel", abs_grad_y);
    //合并梯度
    cv::addWeighted(abs_grad_x, 0.5, abs_grad_y, 0.5, 0, dst);
    cv::imshow("ALL", dst);
    cv::waitKey(0);
    return 0;
}
</pre>

<ul>
<li>输出结果：<center><img src="imgs\18Sobel.jpg" alt=""></center>

</li></ul>
<h3 id="10-3-scharr-">10.3 Scharr算子</h3>
<p>算子：</p>
<center><img src="imgs\Scharr.jpg" alt=""></center>

<pre class="prettyprint lang-c++">
#include < iostream>  
#include < opencv2/core/core.hpp>  
#include < opencv2/highgui/highgui.hpp>  
#include < opencv2/opencv.hpp>
#include < opencv2/imgproc.hpp>
#include < opencv2/core/types_c.h>
#include < opencv2/imgproc/imgproc_c.h>
#include < cassert>  
#include < vector> 

int main(int argc, char* argv)
{
    //读取原始图像
    cv::Mat srcImage = cv::imread("Lena.jfif");
    //将原始图转化为灰度图
    cv::Mat grayImage;
    cv::cvtColor(srcImage, grayImage, cv::COLOR_BGR2GRAY);
    cv::imshow("src", srcImage);
    //创建 grad_x 和 grad_y 矩阵
    cv::Mat grad_x, grad_y,abs_grad_x, abs_grad_y, dst;
    //求 X方向梯度
    cv::Scharr(grayImage, grad_x, CV_16S, 1, 0, 1, 0, cv::BORDER_DEFAULT);
    cv::convertScaleAbs(grad_x, abs_grad_x);
    cv::imshow("X_Scharr", abs_grad_x);
    //求Y方向梯度
    cv::Scharr(grayImage, grad_y, CV_16S, 0, 1, 1, 0, cv::BORDER_DEFAULT);
    cv::convertScaleAbs(grad_y, abs_grad_y);
    cv::imshow("Y_Scharr", abs_grad_y);
    //合并梯度(近似)
    cv::addWeighted(abs_grad_x, 0.5, abs_grad_y, 0.5, 0, dst);
    //显示效果图
    cv::imshow("Scharr", dst);
    cv::waitKey(0);
    return 0;
}
</pre>

<ul>
<li>输出结果：<center><img src="imgs\22Scharr.jpg" alt=""></center>

</li></ul>
<h3 id="10-4-laplacian-">10.4 Laplacian算子</h3>
<p>算子：</p>
<center><img src="imgs\Laplacian.jpg" alt=""></center>

<pre class="prettyprint lang-c++">
#include < iostream>  
#include < opencv2/core/core.hpp>  
#include < opencv2/highgui/highgui.hpp>  
#include < opencv2/opencv.hpp>
#include < opencv2/imgproc.hpp>
#include < opencv2/core/types_c.h>
#include < opencv2/imgproc/imgproc_c.h>
#include < cassert>  
#include < vector> 

int main(int argc, char* argv)
{
    //读取原始图像
    cv::Mat srcImage = cv::imread("Lena.jfif");
    cv::imshow("src", srcImage);
    cv::Mat dst, gray;
    //滤波降噪
    cv::GaussianBlur(srcImage, srcImage, cv::Size(3, 3), 0, 0, cv::BORDER_DEFAULT);
    //转成灰度图
    cv::cvtColor(srcImage, gray, cv::COLOR_BGR2GRAY);
    //运行Sobel算子，得到边缘
    //求x方向梯度
    //Laplacian(src, dst, CV_16S, 3, 1,0,BORDER_DEFAULT);
    cv::Laplacian(srcImage, dst, CV_16S);//后几个参数有默认值
    //由于是16位图片，需要将图片转化成为8位图形进行显示
    cv::convertScaleAbs(dst, dst);
    cv::imshow("ALL", dst);
    cv::waitKey(0);
    return 0;
}
</pre>

<ul>
<li>输出结果：<center><img src="imgs\19Laplace.jpg" alt=""></center>

</li></ul>
<h3 id="10-5-canny-">10.5 Canny边缘检测</h3>
<p>算子：</p>
<center><img src="imgs\canny.jpg" alt=""></center>

<pre class="prettyprint lang-c++">

#include < iostream>  
#include < opencv2/core/core.hpp>  
#include < opencv2/highgui/highgui.hpp>  
#include < opencv2/opencv.hpp>
#include < opencv2/imgproc.hpp>
#include < opencv2/core/types_c.h>
#include < opencv2/imgproc/imgproc_c.h>
#include < cassert>  
#include < vector> 

int main(int argc, char* argv)
{
    //读取原始图像
    cv::Mat srcImage = cv::imread("Lena.jfif");
    cv::imshow("src", srcImage);
    cv::Mat DstPic, edge, grayImage;
    //创建与src同类型和同大小的矩阵
    DstPic.create(srcImage.size(), srcImage.type());
    //将原始图转化为灰度图
    cv::cvtColor(srcImage, grayImage, cv::COLOR_BGR2GRAY);
    //先使用3*3内核来降噪
    cv::blur(grayImage, edge, cv::Size(3, 3));
    //运行canny算子
    cv::Canny(edge, edge, 3, 6, 3);
    cv::imshow("canny", edge);
    cv::waitKey(0);
    return 0;
}

</pre>

<ul>
<li>输出结果：</li></ul>
<center><img src="imgs\21canny.jpg" alt=""></center>

<h2 id="12-">12. 傅里叶变换</h2>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
